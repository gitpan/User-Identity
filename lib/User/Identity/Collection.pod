
=head1 NAME

User::Identity::Collection - base class for collecting roles of a user


=head1 INHERITANCE

 User::Identity::Collection
   is a User::Identity::Item

 User::Identity::Collection is extended by
   User::Identity::Collection::Emails
   User::Identity::Collection::Locations
   User::Identity::Collection::Systems


=head1 SYNOPSIS

 use User::Identity;
 use User::Identity::Collection;
 my $me    = User::Identity->new(...);
 my $set   = User::Identity::Collection::Emails->new(...);
 $me->addCollection($set);

 # Simpler
 use User::Identity;
 my $me    = User::Identity->new(...);
 my $set   = $me->addCollection(type => 'email', ...)
 my $set   = $me->addCollection('email', ...)

 my @roles = $me->collection('email');  # list of collected items

 my $coll  = $me->collection('email');  # a User::Identity::Collection
 my @roles = $coll->roles;
 my @roles = @$coll;                    # same, by overloading

 my $role  = $me->collection('email')->find($coderef);
 my $role  = $me->collection('location')->find('work');
 my $role  = $me->find(location => 'work');


=head1 DESCRIPTION

The C<User::Identity::Collection> object maintains a set user related
objects.  It helps selecting these objects, which is partially common to
all collections (for instance, each object has a name so you can search
on names), and sometimes specific to the extension of this collection.

Currently imlemented extensions are

=over 4

=item * L<User::Identity::Collection::Locations|User::Identity::Collection::Locations>

=item * L<User::Identity::Collection::Emails|User::Identity::Collection::Emails>

=item * L<User::Identity::Collection::Systems|User::Identity::Collection::Systems>

=back


=head1 OVERLOADED


overload: B<@{}>

=over 4

When the reference to a collection object is used as array-reference, it
will be shown as list of roles.

I<Example:> 

 my $locations = $ui->collection('location');
 foreach my $loc (@$location) ...
 print $location->[0];

=back

overload: B<stringification>

=over 4

Returns the name of the collection and a sorted list of defined items.

I<Example:> 

 print "$collection\n";  #   location: home, work

=back


=head1 METHODS


=head2 Initiation


User::Identity::Collection-E<gt>B<new>([NAME], OPTIONS)

=over 4

 Option       Defined in       Default   
 description  L<User::Identity::Item>  undef     
 item_type                     <required>
 name         L<User::Identity::Item>  <required>
 roles                         undef     
 user                          undef     

. description STRING

. item_type CLASS

=over 4

The CLASS which is used to store the information for each of the maintained
objects within this collection.

=back

. name STRING

. roles ROLE|ARRAY

=over 4

Immediately add some roles to this collection.  In case of an ARRAY,
each element of the array is passed separately to L<addRole()|User::Identity::Collection/"Attributes">. So,
you may end-up with an ARRAY of arrays each grouping a set of options
to create a role.

=back

. user OBJECT

=over 4

The user which has this collection of roles.

=back

=back

=head2 Attributes


$obj-E<gt>B<addRole>(ROLE| ( [NAME],OPTIONS ) | ARRAY-OF-OPTIONS)

=over 4

Adds a new role to this collection.  ROLE is an object of the right type
(depends on the extension of this module which type that is) or a list
of OPTIONS which are used to create such role.  The options can also be
passed as reference to an array.  The added role is returned.

I<Example:> 

 my $uicl = User::Identity::Collection::Locations->new;

 my $uil  = User::Identity::Location->new(home => ...);
 $uicl->addRole($uil);

 $uicl->addRole( home => address => 'street 32' );
 $uicl->addRole( [home => address => 'street 32'] );

Easier

 $ui      = User::Identity;
 $ui->add(location => 'home', address => 'street 32' );
 $ui->add(location => [ 'home', address => 'street 32' ] );

=back

$obj-E<gt>B<description>

=over 4

See L<User::Identity::Item/"Attributes">

=back

$obj-E<gt>B<name>

=over 4

See L<User::Identity::Item/"Attributes">

=back

$obj-E<gt>B<roles>

=over 4

Returns all defined roles within this collection.  Be warned: the rules
are returned in random (hash) order.

=back

$obj-E<gt>B<user>([USER])

=over 4

The user whose address this is.  This is a weak link, which means that
the location object will be removed when the user object is deleted and
no other references to this location object exist.

=back

=head2 Searching


$obj-E<gt>B<find>(NAME|CODE|undef)

=over 4

Find the object with the specified NAME in this collection.  With C<undef>,
a randomly selected role is returned.

When a code reference is specified, all collected roles are scanned one
after the other (in unknown order).  For each role,

 CODE->($object, $collection)

is called.  When the CODE returns true, the role is selected.  In list context,
all selected roles are returned.  In scalar context, the first match is
returned and the scan is aborted immediately.

I<Example:> 

 my $emails = $ui->collection('emails');
 $emails->find('work');

 sub find_work($$) {
    my ($mail, $emails) = @_;
    $mail->location->name eq 'work';
 }
 my @at_work = $emails->find(\&find_work);
 my @at_work = $ui->find(location => \&find_work);
 my $any     = $ui->find(location => undef );

=back



=head1 DIAGNOSTICS

I<Error:> Cannot create a $type to add this to my collection.

Some options are specified to create a $type object, which is native to
this collection.  However, for some reason this failed.

I<Error:> Wrong type of role for $collection: requires a $expect but got a $type

Each $collection groups sets of roles of one specific type ($expect).  You
cannot add objects of a different $type.






=head1 REFERENCES

See the User::Identity website at L<http://perl.overmeer.net/userid/> for more details.

=head1 COPYRIGHTS

User::Identity version 0.06.
Written by Mark Overmeer (mark@overmeer.net).  See the ChangeLog for
other contributors.

Copyright (c) 2003 by the author(s). All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.


